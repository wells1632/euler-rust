10 REM TOTIENT PERMUTATION FINDER
20 REM WARNING: VERY SLOW AND LIMITED BY BASIC PRECISION
30 REM USING SMALLER LIMIT DUE TO PERFORMANCE
40 LM = 100000: REM REDUCED FROM 10^7
50 DIM P(5000): REM ARRAY TO STORE PRIMES
55 DIM D1(10), D2(10): REM DIGIT COUNT ARRAYS
60 GOSUB 1000: REM GENERATE PRIMES
70 GOSUB 2000: REM FIND BEST N
80 PRINT "N = "; BN
90 PRINT "PHI(N) = "; BP
100 PRINT "N/PHI(N) = "; BR
110 END

1000 REM SUBROUTINE: GENERATE PRIMES UP TO SQRT(LM)*2
1010 L2 = INT( SQR(LM)) * 2
1020 DIM IP(L2): REM IS_PRIME ARRAY
1030 FOR I = 2 TO L2: IP(I) = 1: NEXT I
1040 FOR I = 2 TO INT( SQR(L2))
1050   IF IP(I) = 0 THEN GOTO 1090
1060   FOR J = I * I TO L2 STEP I
1070     IP(J) = 0
1080   NEXT J
1090 NEXT I
1100 PC = 0: REM PRIME COUNT
1110 FOR I = 2 TO L2
1120   IF IP(I) = 1 THEN P(PC) = I: PC = PC + 1
1130 NEXT I
1140 RETURN

2000 REM SUBROUTINE: FIND BEST N
2010 BR = 1E38: REM BEST RATIO (INITIALIZE TO LARGE VALUE)
2020 BN = 0: REM BEST N
2030 BP = 0: REM BEST PHI
2040 FOR I = 0 TO PC - 1
2050   FOR J = I TO PC - 1
2060     P1 = P(I)
2070     Q1 = P(J)
2080     N = P1 * Q1
2090     IF N >= LM THEN GOTO 2180
2100     PH = (P1 - 1) * (Q1 - 1)
2110     GOSUB 3000: REM CHECK IF PERMUTATION
2120     IF PM = 0 THEN GOTO 2170
2130     R = N / PH
2140     IF R < BR THEN BR = R: BN = N: BP = PH
2170   NEXT J
2180 NEXT I
2190 RETURN

3000 REM SUBROUTINE: CHECK IF N AND PH ARE PERMUTATIONS
3010 FOR K = 0 TO 9: D1(K) = 0: D2(K) = 0: NEXT K
3020 T = N
3030 IF T < 1 THEN GOTO 3070
3040   D = T - INT(T / 10) * 10
3050   D1(D) = D1(D) + 1
3060   T = INT(T / 10): GOTO 3030
3070 T = PH
3080 IF T < 1 THEN GOTO 3120
3090   D = T - INT(T / 10) * 10
3100   D2(D) = D2(D) + 1
3110   T = INT(T / 10): GOTO 3080
3120 PM = 1: REM ASSUME PERMUTATION
3130 FOR K = 0 TO 9
3140   IF D1(K) <> D2(K) THEN PM = 0
3150 NEXT K
3160 RETURN